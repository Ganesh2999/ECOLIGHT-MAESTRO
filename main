#include <LPC21xx.h>
#include "type.h"
#include "pins_main.h"
#include "defines.h"
#include "adc.h"
#include "kpm.h"
#include "delay.h"
#include "Lcd.h"
#include "rtc.h"
#include "mini_inte.h"
#include "lcd_define.h"
volatile u32 eint0_flag = 0;
volatile u8 in_menu = 0;
#define button 16
s32 hour, min, sec, date, month, year, day;
#define SLED 1

    u32 adcVal;
   // float eAR;

int main()
{

     Init_kpm();
   Init_LCD();
	  Init_ADC();
	RTC_Init();
    //delay_ms(1);
    enable_eint0();
	  IODIR0|=0X0F<<SLED;
	  //IOCLR0=1<<SLED;
    // Initial display
	SetRTCTimeInfo(0,27,40);
    GetRTCTimeInfo(&hour, &min, &sec);
    DisplayRTCTime(hour, min, sec);
    GetRTCDateInfo(&date, &month, &year);
    DisplayRTCDate(date, month, year);
    GetRTCDay(&day);
    DisplayRTCDay(day);
while(1) {
	      Read_ADC(1, &adcVal);			// adjust channel if needed
			 CmdLCD(GOTO_LINE2_POS0+12);
			  u32lcd(adcVal);
    // Auto streetlight logic
     if((hour>=18&&hour<=23)||(hour>=0&&hour<= 6))
			{
        if(adcVal>101){  
            IOSET0=0X0F<<SLED;   // Turn ON LED in dark
        } else {
            IOCLR0=0X0F<<SLED;   // Turn OFF LED in light
        }
    }
			else {
        IOCLR0 = 0x0F << SLED;       // Daytime: force LED off
			}

    // Handle external interrupt for menu
    if(eint0_flag) {
         
        handleMenu();
        eint0_flag = 0;
   
    } else {
        
            GetRTCTimeInfo(&hour, &min, &sec);
            DisplayRTCTime(hour, min, sec);
            GetRTCDateInfo(&date, &month, &year);
            DisplayRTCDate(date, month, year);
            GetRTCDay(&day);
            DisplayRTCDay(day);
        }
    

    delay_ms(100);
}
}
//.............mini_inte.c.........
#include <LPC21xx.h>
#include "mini_inte.h"
#include "LCD.h"
#include "lcd.h"
#include "delay.h"
#include "rtc.h"
#include "kpm.h"
#include "Pin_connect_block.h"
#include "type.h"
#include "lcd_define.h"
extern volatile u32 eint0_flag;
char inp(){
char key='\0';
do{
key=keyScan();
while(ColScan==0);
delay_ms(400);
CharLCD(key);
}while(key=='\0');

return key;
}

u32 readnum(){
  int num=0,key;
	while(1){
		key='\0';
    key=keyScan();
    while(ColScan()==0);
		delay_ms(200);
    
    if(key>='0' && key<='9'){
			CharLCD(key);
      num=num*10+(key-'0');
    }
    
     if(key=='='){
      break;
    }
  }
  return num;
}
int  check_val(u32 *x,int low,int high){
  if(!(*x>=low && *x<=high)){
    return 0;
  }
  return 1;
}
void genral(){
      CmdLCD(CLEAR_LCD);
      Str_LCD("enter val again");
      delay_ms(700);
}

void  handleMenu(){
char opt1='\0';
unsigned int menu=1; // for continues running default menu is 0
unsigned int val;
while(menu!=0){
     CmdLCD(CLEAR_LCD);
  Str_LCD("1.HR 2.MIN 3.SEC");
  CmdLCD(GOTO_LINE2_POS0);
  Str_LCD("4.DY 5.DM 6.yr");
	opt1=inp();
  delay_ms(1500);
	
if(opt1!='\0'){
	CmdLCD(CLEAR_LCD);
  Str_LCD("ent value:");
}
	switch(opt1){
		case '1': 
    val=readnum();
    if(!check_val(&val,0,23)){
			genral();
      break;
    }
    SetRTCHour(val);
    break;
    case '2': 
    val=readnum();
    if(!check_val(&val,0,59)){
			genral();
      break;
    }
    SetRTCMin(val);
    break;
    case '3': 
    val=readnum();
    if(!check_val(&val,0,59)){
			genral();
      break;
    }
    SetRTCSec(val);
    break;
    case '4': 
    val=readnum();
    if(!check_val(&val,1,31)){
			genral();
      break;
    }
    SetRTCDate(val);
    break;
    case '5': 
    val=readnum();
    if(!check_val(&val,1,12)){
			genral();
      break;
    }
    SetRTCMonth(val);
    break;
    case '6': 
    val=readnum();
    if(!check_val(&val,1000,9999)){
			genral();
      break;
    }
    SetRTCYear(val);
    break;
    default :
			CmdLCD(CLEAR_LCD);
    Str_LCD("exiting");
		menu=0;// menu 0 for existing
    delay_ms(500);    
	
  }
}
}



void eint0qw(void)__irq
{
    eint0_flag = 1;      
	
  // set flag for main
    EXTINT = 1<<0;         // clear EINT0
    VICVectAddr = 0;       // Acknowledge
}
//Enable EINT0
void enable_eint0(void)
{
    // Configure P0.16 as EINT0
    PINSEL1 |= (1<<0);
    PINSEL1 &= ~(1<<1);

    VICIntEnable = 1<<EINT0;                  // enable EINT0
    VICVectCntl0 = (1<<5) | EINT0;            // slot enable
    VICVectAddr0 = (unsigned int)eint0qw;   // ISR address

    EXTMODE = 1<<0;        // edge triggered
    //EXTPOLAR &= ~(1<<0);   // falling edge
}
//..................adc.c.........................
#include <LPC21xx.h>
#include "delay.h"
#include "Pin_connect_block.h"
#include "adc_defines.h"
void Init_ADC(void){
    //cfg p0.27 as  (analog input pins 0)
    CfgPortPinFunc(0,27,1);
    //cfg ADCR
    ADCR=((CLKDIV<<CLKDIV_BITS)|(1<<pdn_bit));
}
void Read_ADC(unsigned int chNo,unsigned int* adcVal)//equivivalent analog result
{
    //mask any prev channel set
    ADCR &=0xffffff00;
    //write channel for analog read
    ADCR|=(1<<chNo)|(1<<ADC_CONV_START_BIT);
    delay_ms(3);
    //wait untill conversion complete
    while(((ADDR>>DONE_BIT)&1)==0);
    //stop adc conveert wrt that channel
    ADCR &=~(1<<ADC_CONV_START_BIT);
    //read digital bits
    *adcVal=((ADDR>>DIGITAL_DATA_BITS)&1023);
    //EQYUIVALENT VALUEB/W 0 TO 3.3
   // *eAR=(*adcVal*(3.3/1024));
}
//........................rtc.c..............
#include <LPC21xx.H>

#include "rtc_define.h"
#include "type.h"
#include "lcd.h"
#include "lcd_define.h"

// Array to hold names of days of the week
char week[][4] = {"SAT","MON","TUE","WED","THU","FRI","SUN"};


/*
Initialize the Real-Time Clock (RTC)
This function disables the RTC, sets the prescaler values, 
and then enables the RTC.
*/
void RTC_Init(void) 
{
  // Disable and reset the RTC
	CCR = RTC_RESET;
  
  // Set prescaler integer and fractional parts
	PREINT = PREINT_VAL;
	PREFRAC = PREFRAC_VAL;
  
  // Enable the RTC
	CCR = RTC_ENABLE;
}

/*
Get the current RTC time
hour Pointer to store the current hour
minute Pointer to store the current minute
second Pointer to store the current second
*/
  
void GetRTCTimeInfo(s32 *hour, s32 *minute, s32 *second)
{
	*hour = HOUR;
	*minute = MIN;
	*second = SEC;
}

/*
Display the RTC time on LCD
hour value (0 23)
minute value (0 59)
second value (0 59) seperated by ':'
*/
void DisplayRTCTime(u32 hour, u32 minute, u32 second)
{
	CmdLCD(GOTO_LINE1_POS0);
	CharLCD((hour/10)+48);
	CharLCD((hour%10)+48);
	CharLCD(':');
	CharLCD((minute/10)+48);
	CharLCD((minute%10)+48);
	CharLCD(':');
	CharLCD((second/10)+48);
	CharLCD((second%10)+48);
}

/*
Get the current RTC date
day Pointer to store the current date (1 31)
month Pointer to store the current month (1 12)
year Pointer to store the current year (four digits)
*/
void GetRTCDateInfo(s32 *date, s32 *month, s32 *year)
{
	*date = DOM;
	*month = MONTH;
	*year = YEAR;
}

/*
Display the RTC date on LCD
Day of month (1 31)
Month (1 12)
Year (four digits) and seperated by '/'
*/
void DisplayRTCDate(u32 date, u32 month, u32 year)
{
	CmdLCD(GOTO_LINE2_POS0);
	CharLCD((date/10)+48);
	CharLCD((date%10)+48);
	CharLCD('/');
	CharLCD((month/10)+48);
	CharLCD((month%10)+48);
	CharLCD('/');
	u32lcd(year);
}

/*
Set the RTC time
Hour to set (0 23)
Minute to set (0 59)
Second to set (0 59)
*/
void SetRTCTimeInfo(u32 hour, u32 minute, u32 second)
{
	HOUR = hour;
	MIN = minute;
	SEC = second;
}
void SetRTCHour(u32 hour){
	HOUR=hour;
}

void SetRTCMin(u32 min){
	MIN=min;
}

void SetRTCSec(u32 sec){
	SEC=sec;
}

/*
Set the RTC date
day of month to set (1 31)
month to set (1 12)
year to set (four digits)
*/
void SetRTCDateInfo(u32 date, u32 month, u32 year)
{
	DOM = date;
	MONTH = month;
	YEAR = year;
}
void SetRTCDate(u32 date){
	DOM=date;
}

void SetRTCMonth(u32 month){
	MONTH=month;
}

void SetRTCYear(u32 year){
	YEAR=year;
}
/*
Get the current day of the week
dow Pointer to store Day of Week (0=Sunday, ..., 6=Saturday)
*/
void GetRTCDay(s32 *day)
{
	*day = DOW;
}

/*
Display the current day of the week on LCD
dow (Day of Week) (0=Sunday, ..., 6=Saturday)
*/
void DisplayRTCDay(u32 day)
{
	CmdLCD(GOTO_LINE1_POS0+10);
	Str_LCD(week[day]);
  
}

/*
Set the day of the week in RTC
Day of Week to set (0=Sunday, ..., 6=Saturday)
*/
void SetRTCDay(u32 day)
{
	DOW = day;
}
//....................lcd.c...............
#include<LPC21xx.h>
#include "defines.h"
#include "delay.h"
#include "lcd_define.h"
void WriteLCD(unsigned char anyByte){

IOCLR0=1<<LCD_RW; // SELECTING WRITE OPERATIONS
WRITEBYTE(IOPIN1,LCD_DATA,anyByte);// Write data/command byte to LCD data lines

IOSET0=1<<LCD_EN;
delay_us(1);
IOCLR0=1<<LCD_EN;// FOR HIGHTO LOW PULSE to EN

delay_us(37);
}
void CmdLCD(unsigned char cmd){
    IOCLR0=1<<LCD_RS; //SELECTING 
    //WRITE CMD TO RG
    WriteLCD(cmd);
    delay_ms(2);

}
void CharLCD(unsigned char asciiVal){
    // select data register
    IOSET0=1<<LCD_RS;
    //write ascii vio data reg to ddram
    WriteLCD(asciiVal);

}

void Init_LCD (void) {
    // Configure P0.8â€“P0.15 as data output
    // Configure P0.16 (RS), P0.17 (RW), P0.18 (EN) as control output
    IODIR0|=(1 << LCD_RS) | (1 << LCD_RW) | (1 << LCD_EN);
	  IODIR1|=(0xFFU << LCD_DATA) ;
    delay_ms(15);         // Wait for LCD power-on stabilization

    // Reset sequence as per HD44780 datasheet
    CmdLCD(0x30);         // Function Set (8-bit)
    delay_ms(5);  
    CmdLCD(0x30); 
    delay_us(100);
    CmdLCD(0x30); 

    // Now send actual initialization commands
    CmdLCD(MODE_8BIT_2LINE);     // 8-bit, 2-line display
    CmdLCD(DSP_ON_CUR_ON);    // Display ON, Cursor ON, Blinking ON
    CmdLCD(CLEAR_LCD);           // Clear display
    CmdLCD(SHIFT_CUR_RIGHT);     // Set cursor move direction
}

void Str_LCD(char*p){
    while(*p){
        CharLCD((*p++));
    }
}

void u32lcd(unsigned int num){
    unsigned char a[10];
    int i = 0;

    if(num == 0){
        CharLCD('0');
        return;
    }

    while(num > 0){
        a[i++] = (num % 10) + '0';
        num /= 10;
    }

    while(i--){
        CharLCD(a[i]);
    }
}

void StrLCD(int snum){
    if(snum<0){
        CharLCD('-');
        snum=-snum;
    }
    u32lcd(snum);

}

void F32LCD(float fNum, unsigned char nDP){
	unsigned char i;
    unsigned int intPart;
    if(fNum < 0){
        CharLCD('-');
        fNum = -fNum;
    }
	 intPart = (unsigned int)fNum;
    u32lcd(intPart);

    CharLCD('.');

    fNum = fNum - intPart;

    for(i = 0; i < nDP; i++){
        fNum *= 10;
        intPart = (unsigned int)fNum;
        CharLCD(intPart + '0');
        fNum -= intPart;
    }
}

void BuildCGRAM(unsigned char *p,unsigned char nBytes){
    unsigned int i;
    //goto CGRAM START
    CmdLCD(GOTO_CGRAM_START);
    //select data register
    IOSET0=1<<LCD_RS;
    for(i=0;i<nBytes;i++){
        WriteLCD(p[i]);
    }
    // return back to ddram
    CmdLCD(GOTO_LINE1_POS0);

}
//........................kpm.c.............
#include <lpc21xx.h>
#include "lcd.h"
#include "delay.h"
#define row 16
#define col 20
const unsigned char arr[4][4]=
{
	{'7','8','9','/'},
	{'4','5','6','*'},
	{'1','2','3','-'},
	{'c','0','=','+'},
};
void Init_kpm(void)
{
	 IODIR1|=15<<row;
}
unsigned int ColScan(void)
{
	if(((IOPIN1>>col)&15)<15)
		return 0;
	else
		return 1;
}
unsigned int row_cheak(void)
{
	unsigned int i;
	for(i=0;i<4;i++)
	{
		IOPIN1=((IOPIN1&~(15<<row))|(~(1<<i)<<row));
		if(ColScan()==0)
			break;
	}
			IOPIN1=((IOPIN1&~(15<<row))|(0<<row));
	return i;
}
unsigned int col_cheak(void)
{
	unsigned int i;
	for(i=0;i<4;i++)
	{
		if(((IOPIN1>>(col+i))&1)==0)
			break;
	}
	return i;
}

unsigned char keyScan(void)
{
	unsigned char rno,cno,keyv;
	while(ColScan());
	rno=row_cheak();
	cno=col_cheak();
	keyv=arr[rno][cno];
   while(!ColScan());
	return keyv;
}
void Read_Number(unsigned int*num,char *key)
{
	
	*num=0;
	while(1){
     while(ColScan());
	  *key=keyScan();
	if(*key>='0'&&*key<='9')
	{
		*num=(*num*10+(*key-48));
	}
	else
		break;
 }
}
	









