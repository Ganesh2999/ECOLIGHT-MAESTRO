#include <LPC21xx.h>
#include "type.h"
#include "pins_main.h"
#include "defines.h"
#include "adc.h"
#include "kpm.h"
#include "delay.h"
#include "Lcd.h"
#include "rtc.h"
#include "mini_inte.h"
#include "lcd_define.h"
volatile u32 eint0_flag = 0;
volatile u8 in_menu = 0;
#define button 16
s32 hour, min, sec, date, month, year, day;
#define SLED 1

    u32 adcVal;
   // float eAR;

int main()
{

     Init_kpm();
   Init_LCD();
	  Init_ADC();
	RTC_Init();
    //delay_ms(1);
    enable_eint0();
	  IODIR0|=0X0F<<SLED;
	  //IOCLR0=1<<SLED;
    // Initial display
	SetRTCTimeInfo(0,27,40);
    GetRTCTimeInfo(&hour, &min, &sec);
    DisplayRTCTime(hour, min, sec);
    GetRTCDateInfo(&date, &month, &year);
    DisplayRTCDate(date, month, year);
    GetRTCDay(&day);
    DisplayRTCDay(day);
while(1) {
	      Read_ADC(1, &adcVal);			// adjust channel if needed
			 CmdLCD(GOTO_LINE2_POS0+12);
			  u32lcd(adcVal);
    // Auto streetlight logic
     if((hour>=18&&hour<=23)||(hour>=0&&hour<= 6))
			{
        if(adcVal>101){  
            IOSET0=0X0F<<SLED;   // Turn ON LED in dark
        } else {
            IOCLR0=0X0F<<SLED;   // Turn OFF LED in light
        }
    }
			else {
        IOCLR0 = 0x0F << SLED;       // Daytime: force LED off
			}

    // Handle external interrupt for menu
    if(eint0_flag) {
         
        handleMenu();
        eint0_flag = 0;
   
    } else {
        
            GetRTCTimeInfo(&hour, &min, &sec);
            DisplayRTCTime(hour, min, sec);
            GetRTCDateInfo(&date, &month, &year);
            DisplayRTCDate(date, month, year);
            GetRTCDay(&day);
            DisplayRTCDay(day);
        }
    

    delay_ms(100);
}
}



//....................lcd.c...............
#include<LPC21xx.h>
#include "defines.h"
#include "delay.h"
#include "lcd_define.h"
void WriteLCD(unsigned char anyByte){

IOCLR0=1<<LCD_RW; // SELECTING WRITE OPERATIONS
WRITEBYTE(IOPIN1,LCD_DATA,anyByte);// Write data/command byte to LCD data lines

IOSET0=1<<LCD_EN;
delay_us(1);
IOCLR0=1<<LCD_EN;// FOR HIGHTO LOW PULSE to EN

delay_us(37);
}
void CmdLCD(unsigned char cmd){
    IOCLR0=1<<LCD_RS; //SELECTING 
    //WRITE CMD TO RG
    WriteLCD(cmd);
    delay_ms(2);

}
void CharLCD(unsigned char asciiVal){
    // select data register
    IOSET0=1<<LCD_RS;
    //write ascii vio data reg to ddram
    WriteLCD(asciiVal);

}

void Init_LCD (void) {
    // Configure P0.8â€“P0.15 as data output
    // Configure P0.16 (RS), P0.17 (RW), P0.18 (EN) as control output
    IODIR0|=(1 << LCD_RS) | (1 << LCD_RW) | (1 << LCD_EN);
	  IODIR1|=(0xFFU << LCD_DATA) ;
    delay_ms(15);         // Wait for LCD power-on stabilization

    // Reset sequence as per HD44780 datasheet
    CmdLCD(0x30);         // Function Set (8-bit)
    delay_ms(5);  
    CmdLCD(0x30); 
    delay_us(100);
    CmdLCD(0x30); 

    // Now send actual initialization commands
    CmdLCD(MODE_8BIT_2LINE);     // 8-bit, 2-line display
    CmdLCD(DSP_ON_CUR_ON);    // Display ON, Cursor ON, Blinking ON
    CmdLCD(CLEAR_LCD);           // Clear display
    CmdLCD(SHIFT_CUR_RIGHT);     // Set cursor move direction
}

void Str_LCD(char*p){
    while(*p){
        CharLCD((*p++));
    }
}

void u32lcd(unsigned int num){
    unsigned char a[10];
    int i = 0;

    if(num == 0){
        CharLCD('0');
        return;
    }

    while(num > 0){
        a[i++] = (num % 10) + '0';
        num /= 10;
    }

    while(i--){
        CharLCD(a[i]);
    }
}

void StrLCD(int snum){
    if(snum<0){
        CharLCD('-');
        snum=-snum;
    }
    u32lcd(snum);

}

void F32LCD(float fNum, unsigned char nDP){
	unsigned char i;
    unsigned int intPart;
    if(fNum < 0){
        CharLCD('-');
        fNum = -fNum;
    }
	 intPart = (unsigned int)fNum;
    u32lcd(intPart);

    CharLCD('.');

    fNum = fNum - intPart;

    for(i = 0; i < nDP; i++){
        fNum *= 10;
        intPart = (unsigned int)fNum;
        CharLCD(intPart + '0');
        fNum -= intPart;
    }
}

void BuildCGRAM(unsigned char *p,unsigned char nBytes){
    unsigned int i;
    //goto CGRAM START
    CmdLCD(GOTO_CGRAM_START);
    //select data register
    IOSET0=1<<LCD_RS;
    for(i=0;i<nBytes;i++){
        WriteLCD(p[i]);
    }
    // return back to ddram
    CmdLCD(GOTO_LINE1_POS0);

}
//........................kpm.c.............
#include <lpc21xx.h>
#include "lcd.h"
#include "delay.h"
#define row 16
#define col 20
const unsigned char arr[4][4]=
{
	{'7','8','9','/'},
	{'4','5','6','*'},
	{'1','2','3','-'},
	{'c','0','=','+'},
};
void Init_kpm(void)
{
	 IODIR1|=15<<row;
}
unsigned int ColScan(void)
{
	if(((IOPIN1>>col)&15)<15)
		return 0;
	else
		return 1;
}
unsigned int row_cheak(void)
{
	unsigned int i;
	for(i=0;i<4;i++)
	{
		IOPIN1=((IOPIN1&~(15<<row))|(~(1<<i)<<row));
		if(ColScan()==0)
			break;
	}
			IOPIN1=((IOPIN1&~(15<<row))|(0<<row));
	return i;
}
unsigned int col_cheak(void)
{
	unsigned int i;
	for(i=0;i<4;i++)
	{
		if(((IOPIN1>>(col+i))&1)==0)
			break;
	}
	return i;
}

unsigned char keyScan(void)
{
	unsigned char rno,cno,keyv;
	while(ColScan());
	rno=row_cheak();
	cno=col_cheak();
	keyv=arr[rno][cno];
   while(!ColScan());
	return keyv;
}
void Read_Number(unsigned int*num,char *key)
{
	
	*num=0;
	while(1){
     while(ColScan());
	  *key=keyScan();
	if(*key>='0'&&*key<='9')
	{
		*num=(*num*10+(*key-48));
	}
	else
		break;
 }
}
	









